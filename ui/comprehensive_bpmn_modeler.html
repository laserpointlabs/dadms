<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive BPMN Modeler</title>

    <!-- BPMN.js CSS - must be loaded first -->
    <link rel="stylesheet" href="https://unpkg.com/bpmn-js@17.11.1/dist/assets/diagram-js.css" />
    <link rel="stylesheet" href="https://unpkg.com/bpmn-js@17.11.1/dist/assets/bpmn-font/css/bpmn.css" />

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .view-toggle {
            display: flex;
            gap: 10px;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .toggle-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .main-container {
            display: flex;
            gap: 20px;
            height: 90vh;
        }

        .canvas-container {
            flex: 2;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .canvas {
            width: 100%;
            height: 100%;
        }

        /* Ensure bpmn.io palette is styled properly */
        .djs-palette {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            left: 20px !important;
            top: 20px !important;
        }

        .djs-palette .entry {
            border-radius: 3px;
        }

        .djs-palette .entry:hover {
            background: #e9ecef;
        }

        /* Ensure palette icons are visible */
        .djs-palette .entry div {
            color: #333;
        }

        /* Remove conflicting palette styles */
        .canvas-container .djs-palette {
            position: absolute;
            z-index: 100;
        }

        .properties {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            overflow-y: auto;
        }

        .property-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: #f8f9fa;
        }

        .property-group h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
        }

        .property-field {
            margin-bottom: 15px;
        }

        .property-field label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 12px;
        }

        .property-field input,
        .property-field select,
        .property-field textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
            box-sizing: border-box;
        }

        .property-field textarea {
            min-height: 60px;
            resize: vertical;
        }

        .property-field select {
            background: white;
        }

        .xml-editor {
            width: 100%;
            height: 100%;
            padding: 15px;
            border: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
            box-sizing: border-box;
            resize: none;
            background: #f8f9fa;
            color: #333;
            border-radius: 4px;
            outline: none;
            overflow: auto;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .xml-editor:focus {
            background: #ffffff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .xml-view {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .status {
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hidden {
            display: none;
        }

        .element-info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
        }

        .element-info h3 {
            margin: 0 0 5px 0;
            color: #1976d2;
            font-size: 14px;
        }

        .element-info p {
            margin: 0;
            color: #424242;
            font-size: 12px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .multi-input {
            display: flex;
            gap: 5px;
        }

        .multi-input input {
            flex: 1;
        }

        .add-remove-btn {
            padding: 4px 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .add-remove-btn:hover {
            background: #5a6268;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            width: 100%;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        .delete-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .keyboard-shortcuts {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 11px;
            color: #666;
        }

        .keyboard-shortcuts h5 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 12px;
        }

        .keyboard-shortcuts ul {
            margin: 0;
            padding-left: 15px;
        }

        .keyboard-shortcuts li {
            margin-bottom: 2px;
        }

        /* Ensure the canvas container can handle XML editor scrolling */
        .canvas-container {
            flex: 2;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        /* XML highlight overlay styles */
        .xml-highlight-overlay {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            min-height: 100% !important;
            pointer-events: none !important;
            z-index: 1 !important;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Comprehensive BPMN Modeler</h1>
        <div class="view-toggle">
            <button class="toggle-btn active" onclick="switchView('diagram')">Diagram View</button>
            <button class="toggle-btn" onclick="switchView('xml')">XML View</button>
            <button class="toggle-btn" onclick="clearModel()"
                style="background: #dc3545; color: white; border-color: #dc3545;">Clear All</button>
        </div>
    </div>

    <div id="status" class="status info">Initializing BPMN modeler...</div>

    <div class="main-container">
        <!-- Canvas Container -->
        <div class="canvas-container">
            <div id="canvas" class="canvas"></div>
            <textarea id="xml-editor" class="xml-editor hidden"></textarea>
        </div>

        <!-- Properties Panel -->
        <div class="properties">
            <div class="keyboard-shortcuts">
                <h5>Keyboard Shortcuts:</h5>
                <ul>
                    <li><strong>Delete</strong> - Delete selected element</li>
                    <li><strong>Ctrl+Z</strong> - Undo</li>
                    <li><strong>Ctrl+Y</strong> - Redo</li>
                    <li><strong>Ctrl+S</strong> - Export diagram</li>
                    <li><strong>Ctrl+Shift+S</strong> - Manual save to cache</li>
                    <li><strong>Ctrl+R</strong> - Refresh canvas</li>
                </ul>
            </div>
            <div id="properties-content">
                <p>Select a BPMN element to edit its properties</p>
            </div>
        </div>
    </div>

    <div class="xml-view">
        <strong>Current XML:</strong>
        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
            ðŸ’¡ Switch to XML View to edit directly - changes auto-save every 500ms
        </div>
        <pre id="xml-output">Loading...</pre>
    </div>

    <!-- BPMN.js -->
    <script src="https://unpkg.com/bpmn-js@17.11.1/dist/bpmn-modeler.production.min.js"></script>

    <script>
        let modeler;
        let selectedElement = null;
        let currentView = 'diagram';

        // Empty BPMN XML to start from scratch
        const emptyXML = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
    xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
    xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
    xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
    xmlns:camunda="http://camunda.org/schema/1.0/bpmn"
    xmlns:service="http://example.com/service"
    xmlns:script="http://example.com/script"
    xmlns:call="http://example.com/call"
    xmlns:data="http://example.com/data"
    id="Definitions_1"
    targetNamespace="http://bpmn.io/schema/bpmn">
    <bpmn:process id="Process_1" name="New Process" isExecutable="true">
    </bpmn:process>
    <bpmndi:BPMNDiagram id="BPMNDiagram_1">
        <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
        </bpmndi:BPMNPlane>
    </bpmndi:BPMNDiagram>
</bpmn:definitions>`;

        function updateStatus(message, type = 'success') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Function to inject service task extensions
        function injectServiceTaskExtensions(xml, elementId, attrs) {
            console.log('Injecting extensions for element:', elementId);
            console.log('Attributes to inject:', attrs);

            // Extract the actual attributes - now they should be stored directly
            let actualAttrs = {};
            if (attrs.$attrs) {
                // Extract service properties from $attrs
                Object.keys(attrs.$attrs).forEach(key => {
                    if (key.startsWith('service:')) {
                        actualAttrs[key] = attrs.$attrs[key];
                    }
                });
            } else {
                // Properties might be stored directly
                Object.keys(attrs).forEach(key => {
                    if (key.startsWith('service:')) {
                        actualAttrs[key] = attrs[key];
                    }
                });
            }

            console.log('Extracted actual attributes:', actualAttrs);

            // Check for service extension properties
            const serviceType = actualAttrs['service:type'];
            const serviceName = actualAttrs['service:name'];
            const serviceVersion = actualAttrs['service:version'];

            console.log('Service properties:', { serviceType, serviceName, serviceVersion });

            if (!serviceType && !serviceName && !serviceVersion) {
                console.log('No service properties to inject');
                return xml;
            }

            // Build extension elements
            let extensionElements = '';
            extensionElements += '\n            <bpmn:extensionElements>';
            if (serviceType) {
                extensionElements += `\n                <camunda:property name="serviceType" value="${serviceType}" />`;
            }
            if (serviceName) {
                extensionElements += `\n                <camunda:property name="serviceName" value="${serviceName}" />`;
            }
            if (serviceVersion) {
                extensionElements += `\n                <camunda:property name="serviceVersion" value="${serviceVersion}" />`;
            }
            extensionElements += '\n            </bpmn:extensionElements>';

            console.log('Extension elements to add:', extensionElements);

            // Handle self-closing service tasks: <bpmn:serviceTask id="..." service:type="..." />
            const selfClosingRegex = new RegExp(
                `(<bpmn:serviceTask[^>]*id="${elementId}"[^>]*)(\\s*/>)`,
                'g'
            );

            let result = xml.replace(selfClosingRegex, (match, startTag, selfClosing) => {
                console.log('Found self-closing service task in XML:', elementId);
                console.log('Start tag:', startTag);

                // Remove service attributes from start tag
                let cleanStartTag = startTag;
                cleanStartTag = cleanStartTag.replace(/\s+service:type="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+service:name="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+service:version="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+\$attrs="\[object Object\]"/g, '');

                console.log('Clean start tag:', cleanStartTag);

                // Convert self-closing to opening tag + content + closing tag
                const newContent = cleanStartTag + '>' + extensionElements + '\n        </bpmn:serviceTask>';
                console.log('New content:', newContent);
                return newContent;
            });

            // Handle regular service tasks with opening/closing tags
            const regularRegex = new RegExp(
                `(<bpmn:serviceTask[^>]*id="${elementId}"[^>]*>)([\\s\\S]*?)(</bpmn:serviceTask>)`,
                'g'
            );

            result = result.replace(regularRegex, (match, startTag, content, endTag) => {
                console.log('Found regular service task in XML:', elementId);
                console.log('Start tag:', startTag);
                console.log('Content:', content);
                console.log('End tag:', endTag);

                // Remove service attributes from start tag
                let cleanStartTag = startTag;
                cleanStartTag = cleanStartTag.replace(/\s+service:type="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+service:name="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+service:version="[^"]*"/g, '');
                cleanStartTag = cleanStartTag.replace(/\s+\$attrs="\[object Object\]"/g, '');

                console.log('Clean start tag:', cleanStartTag);

                // Check if extension elements already exist in content
                if (content.includes('<bpmn:extensionElements>')) {
                    console.log('Extension elements already exist, removing old ones');
                    // Remove existing extension elements
                    content = content.replace(/<bpmn:extensionElements>[\s\S]*?<\/bpmn:extensionElements>/g, '');
                }

                const newContent = cleanStartTag + content + extensionElements + endTag;
                console.log('New content:', newContent);
                return newContent;
            });

            console.log('XML injection result length:', result.length);
            return result;
        }

        function updateXMLView() {
            if (!modeler) return;

            // Store current scroll position if in XML view
            const xmlEditor = document.getElementById('xml-editor');
            let scrollTop = 0;
            let scrollLeft = 0;
            let selectionStart = 0;
            let selectionEnd = 0;

            if (currentView === 'xml' && xmlEditor) {
                scrollTop = xmlEditor.scrollTop;
                scrollLeft = xmlEditor.scrollLeft;
                selectionStart = xmlEditor.selectionStart;
                selectionEnd = xmlEditor.selectionEnd;
            }

            modeler.saveXML({ format: true }).then(result => {
                console.log('Original XML from modeler:', result.xml.substring(0, 500) + '...');

                // Inject extension properties into XML
                let xml = injectExtensionProperties(result.xml);

                console.log('Final XML after injection:', xml.substring(0, 500) + '...');

                document.getElementById('xml-output').textContent = xml;
                if (currentView === 'xml') {
                    xmlEditor.value = xml;

                    // Restore scroll and cursor position
                    setTimeout(() => {
                        xmlEditor.scrollTop = scrollTop;
                        xmlEditor.scrollLeft = scrollLeft;
                        xmlEditor.setSelectionRange(selectionStart, selectionEnd);
                    }, 10);
                }
            }).catch(error => {
                document.getElementById('xml-output').textContent = 'Error: ' + error.message;
            });
        }

        function switchView(view) {
            currentView = view;
            const canvas = document.getElementById('canvas');
            const xmlEditor = document.getElementById('xml-editor');
            const diagramBtn = document.querySelector('.toggle-btn[onclick="switchView(\'diagram\')"]');
            const xmlBtn = document.querySelector('.toggle-btn[onclick="switchView(\'xml\')"]');

            if (view === 'diagram') {
                canvas.classList.remove('hidden');
                xmlEditor.classList.add('hidden');
                diagramBtn.classList.add('active');
                xmlBtn.classList.remove('active');

                // Clean up XML overlay when switching to diagram view
                const overlay = xmlEditor.parentElement.querySelector('.xml-highlight-overlay');
                if (overlay) {
                    overlay.remove();
                }

                updateStatus('Switched to Diagram View', 'success');
            } else if (view === 'xml') {
                canvas.classList.add('hidden');
                xmlEditor.classList.remove('hidden');
                diagramBtn.classList.remove('active');
                xmlBtn.classList.add('active');

                // Sync current XML to editor with extension properties injected
                if (modeler) {
                    modeler.saveXML({ format: true }).then(result => {
                        // Inject extension properties into XML
                        let xml = injectExtensionProperties(result.xml);
                        document.getElementById('xml-editor').value = xml;

                        // Apply styling to the XML editor
                        highlightXML(xmlEditor);

                        updateStatus('Switched to XML View', 'success');
                    }).catch(error => {
                        updateStatus('Error loading XML: ' + error.message, 'error');
                    });
                }
            }
        }

        // Function to refresh canvas
        function refreshCanvas() {
            if (modeler) {
                const canvas = modeler.get('canvas');
                const elementRegistry = modeler.get('elementRegistry');

                // Force a complete redraw
                canvas.zoom('fit-viewport');

                // Trigger a resize event to force redraw
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                    canvas.zoom('fit-viewport');

                    // Force redraw of all elements
                    elementRegistry.forEach(element => {
                        if (element.graphics) {
                            element.graphics.style.display = 'block';
                        }
                    });

                    // Additional redraw trigger
                    canvas.zoom('fit-viewport');
                }, 100);
            }
        }

        function getExtensionProperty(element, propertyName) {
            if (!element || !element.businessObject) return '';
            const attrs = element.businessObject.$attrs || {};
            return attrs[propertyName] || '';
        }

        function updateExtensionProperty(element, propertyName, value) {
            if (!element || !element.businessObject) return;

            console.log('Updating extension property:', propertyName, '=', value);
            console.log('Element:', element.businessObject.id);

            const modeling = modeler.get('modeling');

            // Get existing attributes directly from the element
            let existingAttrs = {};
            if (element.businessObject.$attrs) {
                // Extract only the actual extension properties, not the $attrs wrapper
                Object.keys(element.businessObject.$attrs).forEach(key => {
                    if (key !== '$attrs' && key.startsWith('service:')) {
                        existingAttrs[key] = element.businessObject.$attrs[key];
                    }
                });
            }

            console.log('Existing attributes before update:', existingAttrs);

            // Update the specific property
            if (value && value.trim() !== '') {
                existingAttrs[propertyName] = value;
            } else {
                delete existingAttrs[propertyName];
            }

            console.log('Updated attributes after merge:', existingAttrs);

            // Store properties directly on the element without the $attrs wrapper
            const properties = {};
            Object.keys(existingAttrs).forEach(key => {
                properties[key] = existingAttrs[key];
            });

            modeling.updateProperties(element, properties);

            updateXMLView();
        }

        function updateBasicProperty(propertyName, value) {
            if (!selectedElement) return;

            const modeling = modeler.get('modeling');

            // Handle documentation as a special case
            if (propertyName === 'documentation') {
                const documentation = selectedElement.businessObject.documentation;
                if (!documentation) {
                    // Create new documentation element
                    const bpmnFactory = modeler.get('bpmnFactory');
                    const newDoc = bpmnFactory.create('bpmn:Documentation', {
                        text: value
                    });
                    modeling.updateProperties(selectedElement, {
                        documentation: [newDoc]
                    });
                } else {
                    // Update existing documentation
                    documentation[0].text = value;
                }
            } else {
                // Handle other basic properties
                const properties = {};
                properties[propertyName] = value;
                modeling.updateProperties(selectedElement, properties);
            }

            updateXMLView();
        }

        function updatePropertiesPanel() {
            if (!selectedElement) {
                document.getElementById('properties-content').innerHTML =
                    '<p>Select a BPMN element to edit its properties</p>';
                return;
            }

            const businessObject = selectedElement.businessObject;
            const elementType = businessObject.$type;
            const elementId = businessObject.id;
            const elementName = businessObject.name || '';

            // Determine element category
            const isServiceTask = elementType === 'bpmn:ServiceTask';
            const isScriptTask = elementType === 'bpmn:ScriptTask';
            const isCallActivity = elementType === 'bpmn:CallActivity';
            const isDataStore = elementType === 'bpmn:DataStoreReference';
            const isDataObject = elementType === 'bpmn:DataObjectReference';
            const isGateway = elementType && elementType.includes('Gateway');
            const isStartEvent = elementType === 'bpmn:StartEvent';
            const isEndEvent = elementType === 'bpmn:EndEvent';
            const isUserTask = elementType === 'bpmn:UserTask';
            const isTask = elementType === 'bpmn:Task';

            let html = `
                <div class="element-info">
                    <h3>${elementType.replace('bpmn:', '')}</h3>
                    <p>ID: ${elementId}</p>
                </div>
                
                <div class="property-group">
                    <h4>Basic Properties</h4>
                    <div class="property-field">
                        <label>Name</label>
                        <input type="text" id="element-name" value="${elementName}" 
                               onchange="updateBasicProperty('name', this.value)">
                    </div>
                    <div class="property-field">
                        <label>ID</label>
                        <input type="text" id="element-id" value="${elementId}" 
                               onchange="updateBasicProperty('id', this.value)">
                    </div>
                    <div class="property-field">
                        <label>Element Type</label>
                        <input type="text" value="${elementType}" readonly style="background:#f5f5f5;">
                    </div>
                </div>
            `;

            // Service Task specific properties
            if (isServiceTask) {
                // Get documentation text properly
                let documentationText = '';
                if (businessObject.documentation && businessObject.documentation.length > 0) {
                    documentationText = businessObject.documentation[0].text || '';
                }

                html += `
                    <div class="property-group">
                        <h4>Service Task Properties</h4>
                        <div class="property-field">
                            <label>Documentation</label>
                            <textarea id="service-documentation" 
                                      onchange="updateBasicProperty('documentation', this.value)"
                                      placeholder="Enter service task documentation...">${documentationText}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Service Type</label>
                            <select id="service-type" onchange="updateExtensionProperty(selectedElement, 'service:type', this.value)">
                                <option value="">Select Type</option>
                                <option value="REST" ${getExtensionProperty(selectedElement, 'service:type') === 'REST' ? 'selected' : ''}>REST</option>
                                <option value="SOAP" ${getExtensionProperty(selectedElement, 'service:type') === 'SOAP' ? 'selected' : ''}>SOAP</option>
                                <option value="JAVA" ${getExtensionProperty(selectedElement, 'service:type') === 'JAVA' ? 'selected' : ''}>JAVA</option>
                                <option value="EXPRESSION" ${getExtensionProperty(selectedElement, 'service:type') === 'EXPRESSION' ? 'selected' : ''}>EXPRESSION</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Service Name</label>
                            <input type="text" id="service-name" 
                                   value="${getExtensionProperty(selectedElement, 'service:name')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'service:name', this.value)"
                                   placeholder="e.g., UserService_TEST_WORD">
                        </div>
                        <div class="property-field">
                            <label>Service Version</label>
                            <input type="text" id="service-version" 
                                   value="${getExtensionProperty(selectedElement, 'service:version')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'service:version', this.value)"
                                   placeholder="e.g., 1.0">
                        </div>
                        <div class="property-field">
                            <label>Endpoint URL</label>
                            <input type="text" id="service-endpoint" 
                                   value="${getExtensionProperty(selectedElement, 'service:endpoint')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'service:endpoint', this.value)"
                                   placeholder="https://api.example.com/service">
                        </div>
                        <div class="property-field">
                            <label>Timeout (ms)</label>
                            <input type="number" id="service-timeout" 
                                   value="${getExtensionProperty(selectedElement, 'service:timeout')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'service:timeout', this.value)"
                                   placeholder="5000">
                        </div>
                    </div>
                `;
            }

            // Script Task specific properties
            if (isScriptTask) {
                // Get documentation text properly
                let documentationText = '';
                if (businessObject.documentation && businessObject.documentation.length > 0) {
                    documentationText = businessObject.documentation[0].text || '';
                }

                html += `
                    <div class="property-group">
                        <h4>Script Task Properties</h4>
                        <div class="property-field">
                            <label>Documentation</label>
                            <textarea id="script-documentation" 
                                      onchange="updateBasicProperty('documentation', this.value)"
                                      placeholder="Enter script task documentation...">${documentationText}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Script Format</label>
                            <select id="script-format" onchange="updateExtensionProperty(selectedElement, 'script:format', this.value)">
                                <option value="">Select Format</option>
                                <option value="groovy" ${getExtensionProperty(selectedElement, 'script:format') === 'groovy' ? 'selected' : ''}>Groovy</option>
                                <option value="javascript" ${getExtensionProperty(selectedElement, 'script:format') === 'javascript' ? 'selected' : ''}>JavaScript</option>
                                <option value="python" ${getExtensionProperty(selectedElement, 'script:format') === 'python' ? 'selected' : ''}>Python</option>
                                <option value="ruby" ${getExtensionProperty(selectedElement, 'script:format') === 'ruby' ? 'selected' : ''}>Ruby</option>
                                <option value="shell" ${getExtensionProperty(selectedElement, 'script:format') === 'shell' ? 'selected' : ''}>Shell</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Script Content</label>
                            <textarea id="script-content" 
                                      onchange="updateExtensionProperty(selectedElement, 'script:content', this.value)"
                                      placeholder="Enter your script code here...">${getExtensionProperty(selectedElement, 'script:content')}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Script File Path</label>
                            <input type="text" id="script-file" 
                                   value="${getExtensionProperty(selectedElement, 'script:file')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'script:file', this.value)"
                                   placeholder="/path/to/script.groovy">
                        </div>
                        <div class="property-field">
                            <label>Auto Store Variables</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="script-auto-store" 
                                       ${getExtensionProperty(selectedElement, 'script:autoStoreVariables') === 'true' ? 'checked' : ''}
                                       onchange="updateExtensionProperty(selectedElement, 'script:autoStoreVariables', this.checked)">
                                <label for="script-auto-store">Automatically store script variables</label>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Call Activity specific properties
            if (isCallActivity) {
                // Get documentation text properly
                let documentationText = '';
                if (businessObject.documentation && businessObject.documentation.length > 0) {
                    documentationText = businessObject.documentation[0].text || '';
                }

                html += `
                    <div class="property-group">
                        <h4>Call Activity Properties</h4>
                        <div class="property-field">
                            <label>Documentation</label>
                            <textarea id="call-documentation" 
                                      onchange="updateBasicProperty('documentation', this.value)"
                                      placeholder="Enter call activity documentation...">${documentationText}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Called Element</label>
                            <input type="text" id="call-element" 
                                   value="${businessObject.calledElement || ''}" 
                                   onchange="updateBasicProperty('calledElement', this.value)"
                                   placeholder="Process_1">
                        </div>
                        <div class="property-field">
                            <label>Called Element Type</label>
                            <select id="call-type" onchange="updateExtensionProperty(selectedElement, 'call:type', this.value)">
                                <option value="">Select Type</option>
                                <option value="process" ${getExtensionProperty(selectedElement, 'call:type') === 'process' ? 'selected' : ''}>Process</option>
                                <option value="case" ${getExtensionProperty(selectedElement, 'call:type') === 'case' ? 'selected' : ''}>Case</option>
                                <option value="globalTask" ${getExtensionProperty(selectedElement, 'call:type') === 'globalTask' ? 'selected' : ''}>Global Task</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Inherit Variables</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="call-inherit" 
                                       ${getExtensionProperty(selectedElement, 'call:inheritVariables') === 'true' ? 'checked' : ''}
                                       onchange="updateExtensionProperty(selectedElement, 'call:inheritVariables', this.checked)">
                                <label for="call-inherit">Inherit variables from parent process</label>
                            </div>
                        </div>
                        <div class="property-field">
                            <label>Variable Mapping</label>
                            <textarea id="call-mapping" 
                                      onchange="updateExtensionProperty(selectedElement, 'call:variableMapping', this.value)"
                                      placeholder="Define variable mappings (JSON format)...">${getExtensionProperty(selectedElement, 'call:variableMapping')}</textarea>
                        </div>
                    </div>
                `;
            }

            // Data Store specific properties
            if (isDataStore) {
                html += `
                    <div class="property-group">
                        <h4>Data Store Properties</h4>
                        <div class="property-field">
                            <label>Data Store Name</label>
                            <input type="text" id="datastore-name" 
                                   value="${businessObject.name || ''}" 
                                   onchange="updateBasicProperty('name', this.value)"
                                   placeholder="Customer Database">
                        </div>
                        <div class="property-field">
                            <label>Data Store Type</label>
                            <select id="datastore-type" onchange="updateExtensionProperty(selectedElement, 'data:type', this.value)">
                                <option value="">Select Type</option>
                                <option value="database" ${getExtensionProperty(selectedElement, 'data:type') === 'database' ? 'selected' : ''}>Database</option>
                                <option value="file" ${getExtensionProperty(selectedElement, 'data:type') === 'file' ? 'selected' : ''}>File System</option>
                                <option value="cache" ${getExtensionProperty(selectedElement, 'data:type') === 'cache' ? 'selected' : ''}>Cache</option>
                                <option value="queue" ${getExtensionProperty(selectedElement, 'data:type') === 'queue' ? 'selected' : ''}>Message Queue</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Connection String</label>
                            <input type="text" id="datastore-connection" 
                                   value="${getExtensionProperty(selectedElement, 'data:connection')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'data:connection', this.value)"
                                   placeholder="jdbc:mysql://localhost:3306/database">
                        </div>
                        <div class="property-field">
                            <label>Capacity</label>
                            <input type="text" id="datastore-capacity" 
                                   value="${getExtensionProperty(selectedElement, 'data:capacity')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'data:capacity', this.value)"
                                   placeholder="1GB">
                        </div>
                    </div>
                `;
            }

            // Data Object specific properties
            if (isDataObject) {
                html += `
                    <div class="property-group">
                        <h4>Data Object Properties</h4>
                        <div class="property-field">
                            <label>Data Object Name</label>
                            <input type="text" id="dataobject-name" 
                                   value="${businessObject.name || ''}" 
                                   onchange="updateBasicProperty('name', this.value)"
                                   placeholder="Customer Data">
                        </div>
                        <div class="property-field">
                            <label>Data Type</label>
                            <select id="dataobject-type" onchange="updateExtensionProperty(selectedElement, 'data:type', this.value)">
                                <option value="">Select Type</option>
                                <option value="string" ${getExtensionProperty(selectedElement, 'data:type') === 'string' ? 'selected' : ''}>String</option>
                                <option value="integer" ${getExtensionProperty(selectedElement, 'data:type') === 'integer' ? 'selected' : ''}>Integer</option>
                                <option value="boolean" ${getExtensionProperty(selectedElement, 'data:type') === 'boolean' ? 'selected' : ''}>Boolean</option>
                                <option value="date" ${getExtensionProperty(selectedElement, 'data:type') === 'date' ? 'selected' : ''}>Date</option>
                                <option value="object" ${getExtensionProperty(selectedElement, 'data:type') === 'object' ? 'selected' : ''}>Object</option>
                                <option value="array" ${getExtensionProperty(selectedElement, 'data:type') === 'array' ? 'selected' : ''}>Array</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Default Value</label>
                            <input type="text" id="dataobject-default" 
                                   value="${getExtensionProperty(selectedElement, 'data:defaultValue')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'data:defaultValue', this.value)"
                                   placeholder="Default value">
                        </div>
                        <div class="property-field">
                            <label>Required</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="dataobject-required" 
                                       ${getExtensionProperty(selectedElement, 'data:required') === 'true' ? 'checked' : ''}
                                       onchange="updateExtensionProperty(selectedElement, 'data:required', this.checked)">
                                <label for="dataobject-required">This data object is required</label>
                            </div>
                        </div>
                        <div class="property-field">
                            <label>Description</label>
                            <textarea id="dataobject-description" 
                                      onchange="updateExtensionProperty(selectedElement, 'data:description', this.value)"
                                      placeholder="Describe the purpose of this data object...">${getExtensionProperty(selectedElement, 'data:description')}</textarea>
                        </div>
                    </div>
                `;
            }

            // Gateway specific properties
            if (isGateway) {
                html += `
                    <div class="property-group">
                        <h4>Gateway Properties</h4>
                        <div class="property-field">
                            <label>Gateway Type</label>
                            <input type="text" value="${elementType.replace('bpmn:', '')}" readonly style="background:#f5f5f5;">
                        </div>
                        <div class="property-field">
                            <label>Default Flow</label>
                            <input type="text" id="gateway-default" 
                                   value="${businessObject.default || ''}" 
                                   onchange="updateBasicProperty('default', this.value)"
                                   placeholder="Flow ID">
                        </div>
                        <div class="property-field">
                            <label>Gateway Direction</label>
                            <select id="gateway-direction" onchange="updateExtensionProperty(selectedElement, 'gateway:direction', this.value)">
                                <option value="">Select Direction</option>
                                <option value="Unspecified" ${getExtensionProperty(selectedElement, 'gateway:direction') === 'Unspecified' ? 'selected' : ''}>Unspecified</option>
                                <option value="Converging" ${getExtensionProperty(selectedElement, 'gateway:direction') === 'Converging' ? 'selected' : ''}>Converging</option>
                                <option value="Diverging" ${getExtensionProperty(selectedElement, 'gateway:direction') === 'Diverging' ? 'selected' : ''}>Diverging</option>
                                <option value="Mixed" ${getExtensionProperty(selectedElement, 'gateway:direction') === 'Mixed' ? 'selected' : ''}>Mixed</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Condition Expression</label>
                            <textarea id="gateway-condition" 
                                      onchange="updateExtensionProperty(selectedElement, 'gateway:condition', this.value)"
                                      placeholder="Enter condition expression...">${getExtensionProperty(selectedElement, 'gateway:condition')}</textarea>
                        </div>
                    </div>
                `;
            }

            // User Task specific properties
            if (isUserTask) {
                // Get documentation text properly
                let documentationText = '';
                if (businessObject.documentation && businessObject.documentation.length > 0) {
                    documentationText = businessObject.documentation[0].text || '';
                }

                html += `
                    <div class="property-group">
                        <h4>User Task Properties</h4>
                        <div class="property-field">
                            <label>Documentation</label>
                            <textarea id="user-documentation" 
                                      onchange="updateBasicProperty('documentation', this.value)"
                                      placeholder="Enter user task documentation...">${documentationText}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Assignee</label>
                            <input type="text" id="user-assignee" 
                                   value="${getExtensionProperty(selectedElement, 'assignee')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'assignee', this.value)"
                                   placeholder="user@example.com">
                        </div>
                        <div class="property-field">
                            <label>Candidate Users</label>
                            <input type="text" id="user-candidates" 
                                   value="${getExtensionProperty(selectedElement, 'candidateUsers')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'candidateUsers', this.value)"
                                   placeholder="user1,user2,user3">
                        </div>
                        <div class="property-field">
                            <label>Candidate Groups</label>
                            <input type="text" id="user-groups" 
                                   value="${getExtensionProperty(selectedElement, 'candidateGroups')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'candidateGroups', this.value)"
                                   placeholder="managers,developers">
                        </div>
                        <div class="property-field">
                            <label>Due Date</label>
                            <input type="text" id="user-duedate" 
                                   value="${getExtensionProperty(selectedElement, 'dueDate')}" 
                                   onchange="updateExtensionProperty(selectedElement, 'dueDate', this.value)"
                                   placeholder="2024-12-31T23:59:59">
                        </div>
                        <div class="property-field">
                            <label>Priority</label>
                            <select id="user-priority" onchange="updateExtensionProperty(selectedElement, 'priority', this.value)">
                                <option value="">Select Priority</option>
                                <option value="low" ${getExtensionProperty(selectedElement, 'priority') === 'low' ? 'selected' : ''}>Low</option>
                                <option value="normal" ${getExtensionProperty(selectedElement, 'priority') === 'normal' ? 'selected' : ''}>Normal</option>
                                <option value="high" ${getExtensionProperty(selectedElement, 'priority') === 'high' ? 'selected' : ''}>High</option>
                            </select>
                        </div>
                    </div>
                `;
            }

            // Task properties (for regular tasks)
            if (isTask) {
                // Get documentation text properly
                let documentationText = '';
                if (businessObject.documentation && businessObject.documentation.length > 0) {
                    documentationText = businessObject.documentation[0].text || '';
                }

                html += `
                    <div class="property-group">
                        <h4>Task Properties</h4>
                        <div class="property-field">
                            <label>Documentation</label>
                            <textarea id="task-documentation" 
                                      onchange="updateBasicProperty('documentation', this.value)"
                                      placeholder="Enter task documentation...">${documentationText}</textarea>
                        </div>
                        <div class="property-field">
                            <label>Implementation</label>
                            <input type="text" id="task-implementation" 
                                   value="${businessObject.implementation || ''}" 
                                   onchange="updateBasicProperty('implementation', this.value)"
                                   placeholder="Implementation class or expression">
                        </div>
                    </div>
                `;
            }

            // Event specific properties
            if (isStartEvent || isEndEvent) {
                html += `
                    <div class="property-group">
                        <h4>Event Properties</h4>
                        <div class="property-field">
                            <label>Event Type</label>
                            <select id="event-type" onchange="updateExtensionProperty(selectedElement, 'event:type', this.value)">
                                <option value="">Select Type</option>
                                <option value="message" ${getExtensionProperty(selectedElement, 'event:type') === 'message' ? 'selected' : ''}>Message</option>
                                <option value="timer" ${getExtensionProperty(selectedElement, 'event:type') === 'timer' ? 'selected' : ''}>Timer</option>
                                <option value="signal" ${getExtensionProperty(selectedElement, 'event:type') === 'signal' ? 'selected' : ''}>Signal</option>
                                <option value="error" ${getExtensionProperty(selectedElement, 'event:type') === 'error' ? 'selected' : ''}>Error</option>
                                <option value="escalation" ${getExtensionProperty(selectedElement, 'event:type') === 'escalation' ? 'selected' : ''}>Escalation</option>
                            </select>
                        </div>
                        <div class="property-field">
                            <label>Event Definition</label>
                            <textarea id="event-definition" 
                                      onchange="updateExtensionProperty(selectedElement, 'event:definition', this.value)"
                                      placeholder="Define event properties...">${getExtensionProperty(selectedElement, 'event:definition')}</textarea>
                        </div>
                    </div>
                `;
            }

            document.getElementById('properties-content').innerHTML = html;
        }

        function selectElement(element) {
            selectedElement = element;
            const businessObject = element.businessObject;
            updateStatus(`Selected: ${businessObject.$type} (${businessObject.id})`, 'info');
            updatePropertiesPanel();
        }

        async function initModeler() {
            try {
                updateStatus('Initializing BPMN modeler...', 'info');

                // Check if BPMN.js loaded
                if (typeof BpmnJS === 'undefined') {
                    throw new Error('BPMN.js library not loaded');
                }

                modeler = new BpmnJS({
                    container: '#canvas'
                });

                // Try to load from cache first
                const cachedXML = loadModelFromCache();
                let xmlToLoad = emptyXML;
                let loadMessage = 'Importing empty BPMN diagram...';

                if (cachedXML) {
                    xmlToLoad = cachedXML;
                    loadMessage = 'Loading cached BPMN diagram...';
                }

                updateStatus(loadMessage, 'info');

                await modeler.importXML(xmlToLoad);

                if (cachedXML) {
                    updateStatus('BPMN modeler ready! Cached model loaded. Use the palette on the left to add elements.', 'success');
                } else {
                    updateStatus('BPMN modeler ready! Use the palette on the left to add elements.', 'success');
                }

                // Add event listeners
                modeler.on('element.click', (event) => {
                    selectElement(event.element);
                });

                modeler.on('selection.changed', (event) => {
                    if (event.newSelection && event.newSelection.length > 0) {
                        selectElement(event.newSelection[0]);
                    } else {
                        selectedElement = null;
                        updatePropertiesPanel();
                    }
                });

                modeler.on('element.changed', () => {
                    updateXMLView();
                    // Auto-save to cache
                    saveModelToCache();
                });

                updateXMLView();

            } catch (error) {
                updateStatus('Error: ' + error.message, 'error');
                console.error('Modeler initialization error:', error);
                console.error('Error details:', error.stack);
            }
        }

        // XML Syntax Highlighter - Simplified and Reliable
        function highlightXML(editor) {
            // Remove any existing overlay
            const existingOverlay = editor.parentElement.querySelector('.xml-highlight-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Reset editor styling
            editor.style.background = '#f8f9fa';
            editor.style.color = '#333';
            editor.style.zIndex = 'auto';
            editor.style.position = 'static';

            // For now, let's use a simpler approach without overlay
            // Just ensure the editor is properly styled and functional
            editor.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
            editor.style.fontSize = '12px';
            editor.style.lineHeight = '1.4';
            editor.style.padding = '15px';
            editor.style.border = '1px solid #ddd';
            editor.style.borderRadius = '4px';
            editor.style.outline = 'none';
            editor.style.overflow = 'auto';
            editor.style.overflowX = 'hidden';
            editor.style.overflowY = 'auto';
            editor.style.resize = 'none';
            editor.style.boxSizing = 'border-box';
        }

        // Simplified XML content highlighting (for display purposes only)
        function highlightXMLContent(text) {
            return text
                // XML Declaration
                .replace(/(<\?xml[^?]*\?>)/g, '<span style="color: #0066cc;">$1</span>')
                // Opening tags
                .replace(/(<\/?)([a-zA-Z0-9_:]+)([^>]*?)(>)/g, function (match, open, tagName, attributes, close) {
                    const tagColor = getTagColor(tagName);
                    const attrHighlighted = attributes.replace(/([a-zA-Z0-9_:]+)=["']([^"']*)["']/g,
                        '<span style="color: #cc6600;">$1</span>=<span style="color: #009900;">"$2"</span>');
                    return '<span style="color: #cc0000;">' + open + '</span>' +
                        '<span style="color: ' + tagColor + ';">' + tagName + '</span>' +
                        attrHighlighted +
                        '<span style="color: #cc0000;">' + close + '</span>';
                })
                // Self-closing tags
                .replace(/(<)([a-zA-Z0-9_:]+)([^>]*?)(\/>)/g, function (match, open, tagName, attributes, close) {
                    const tagColor = getTagColor(tagName);
                    const attrHighlighted = attributes.replace(/([a-zA-Z0-9_:]+)=["']([^"']*)["']/g,
                        '<span style="color: #cc6600;">$1</span>=<span style="color: #009900;">"$2"</span>');
                    return '<span style="color: #cc0000;">' + open + '</span>' +
                        '<span style="color: ' + tagColor + ';">' + tagName + '</span>' +
                        attrHighlighted +
                        '<span style="color: #cc0000;">' + close + '</span>';
                });
        }

        // Get color for different tag types
        function getTagColor(tagName) {
            const colors = {
                'bpmn:definitions': '#0066cc',
                'bpmn:process': '#0066cc',
                'bpmn:startEvent': '#009900',
                'bpmn:endEvent': '#cc0000',
                'bpmn:serviceTask': '#cc6600',
                'bpmn:scriptTask': '#cc6600',
                'bpmn:userTask': '#cc6600',
                'bpmn:callActivity': '#cc6600',
                'bpmn:task': '#cc6600',
                'bpmn:sequenceFlow': '#666666',
                'bpmn:exclusiveGateway': '#9933cc',
                'bpmn:parallelGateway': '#9933cc',
                'bpmn:inclusiveGateway': '#9933cc',
                'bpmn:dataStoreReference': '#0099cc',
                'bpmn:dataObjectReference': '#0099cc',
                'bpmndi:BPMNDiagram': '#0066cc',
                'bpmndi:BPMNPlane': '#0066cc',
                'bpmndi:BPMNShape': '#666666',
                'bpmndi:BPMNEdge': '#666666',
                'dc:Bounds': '#666666',
                'di:waypoint': '#666666'
            };

            return colors[tagName] || '#333333';
        }

        // Enhanced XML editor with real-time sync
        function setupXMLEditor() {
            const xmlEditor = document.getElementById('xml-editor');

            // Add event listeners for real-time editing
            xmlEditor.addEventListener('input', debounce(syncXMLFromEditor, 500));

            // Add syntax highlighting and better editing experience
            xmlEditor.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
            xmlEditor.style.fontSize = '12px';
            xmlEditor.style.lineHeight = '1.4';
            xmlEditor.style.tabSize = '2';
            xmlEditor.style.overflow = 'auto';
            xmlEditor.style.overflowX = 'hidden';
            xmlEditor.style.overflowY = 'auto';

            // Enable tab key for indentation
            xmlEditor.addEventListener('keydown', function (e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;

                    // Insert tab at cursor position
                    this.value = this.value.substring(0, start) + '  ' + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 2;
                }
            });

            // Apply initial styling
            highlightXML(xmlEditor);
        }

        // Function to force refresh XML highlighting
        function forceRefreshXMLHighlighting() {
            const xmlEditor = document.getElementById('xml-editor');
            if (xmlEditor && currentView === 'xml') {
                highlightXML(xmlEditor);
            }
        }

        // Handle XML editor changes with real-time sync
        function syncXMLFromEditor() {
            if (currentView === 'xml' && modeler) {
                const xmlEditor = document.getElementById('xml-editor');
                const xmlContent = xmlEditor.value;

                // Store current scroll position and cursor position
                const scrollTop = xmlEditor.scrollTop;
                const scrollLeft = xmlEditor.scrollLeft;
                const selectionStart = xmlEditor.selectionStart;
                const selectionEnd = xmlEditor.selectionEnd;

                modeler.importXML(xmlContent).then(() => {
                    updateStatus('XML updated successfully', 'success');
                    updateXMLView();
                    // Auto-save to cache when XML is edited
                    saveModelToCache();

                    // Restore scroll and cursor position after a short delay
                    setTimeout(() => {
                        xmlEditor.scrollTop = scrollTop;
                        xmlEditor.scrollLeft = scrollLeft;
                        xmlEditor.setSelectionRange(selectionStart, selectionEnd);
                    }, 10);
                }).catch(error => {
                    updateStatus('XML import error: ' + error.message, 'error');
                });
            }
        }

        // Debounce function for XML sync
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initModeler);

        // Setup XML editor when page loads
        document.addEventListener('DOMContentLoaded', setupXMLEditor);

        // Add global debug function
        window.debugModeler = function () {
            console.log('Modeler:', modeler);
            console.log('Selected element:', selectedElement);
            if (selectedElement) {
                console.log('Business object:', selectedElement.businessObject);
                console.log('Attributes:', selectedElement.businessObject.$attrs);
                console.log('Documentation:', selectedElement.businessObject.documentation);
            }
        };

        // Add global delete function
        window.deleteElement = function () {
            deleteSelectedElement();
        };

        // Add global save function
        window.saveModel = function () {
            saveModelToCache();
            updateStatus('Model manually saved to cache', 'success');
        };

        // Add global clear cache function
        window.clearCache = function () {
            clearModelCache();
            updateStatus('Cache cleared', 'success');
        };

        // Add global refresh canvas function
        window.refreshCanvas = function () {
            refreshCanvas();
            updateStatus('Canvas refreshed', 'success');
        };

        // Add global function to force refresh XML highlighting
        window.refreshXMLHighlighting = function () {
            forceRefreshXMLHighlighting();
            updateStatus('XML highlighting refreshed', 'success');
        };

        // Add function to export diagram
        window.exportDiagram = function () {
            if (!modeler) return;

            modeler.saveXML({ format: true }).then(result => {
                // Inject extension properties into XML before exporting
                let xml = injectExtensionProperties(result.xml);

                const blob = new Blob([xml], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'bpmn-diagram.bpmn';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                updateStatus('Diagram exported successfully', 'success');
            }).catch(error => {
                updateStatus('Export error: ' + error.message, 'error');
            });
        };

        // Delete selected element
        function deleteSelectedElement() {
            if (!selectedElement || !modeler) return;

            try {
                const modeling = modeler.get('modeling');
                modeling.removeElements([selectedElement]);

                selectedElement = null;
                updatePropertiesPanel();
                updateXMLView();
            } catch (error) {
                console.error('Delete error:', error);
            }
        }

        // Keyboard event handling
        function handleKeyboardEvents(event) {
            if (!modeler) return;

            // Check if we're in an input field
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                return; // Don't handle keyboard shortcuts when typing
            }

            const command = modeler.get('commandStack');

            switch (event.key) {
                case 'Delete':
                case 'Backspace':
                    event.preventDefault();
                    if (selectedElement) {
                        deleteSelectedElement();
                    }
                    break;
                case 'z':
                case 'Z':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        if (event.shiftKey) {
                            // Ctrl+Shift+Z or Cmd+Shift+Z = Redo
                            if (command.canRedo()) {
                                command.redo();
                                updateStatus('Redo performed', 'success');
                            } else {
                                updateStatus('Nothing to redo', 'info');
                            }
                        } else {
                            // Ctrl+Z or Cmd+Z = Undo
                            if (command.canUndo()) {
                                command.undo();
                                updateStatus('Undo performed', 'success');
                            } else {
                                updateStatus('Nothing to undo', 'info');
                            }
                        }
                        updateXMLView();
                    }
                    break;
                case 'y':
                case 'Y':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        // Ctrl+Y or Cmd+Y = Redo
                        if (command.canRedo()) {
                            command.redo();
                            updateStatus('Redo performed', 'success');
                        } else {
                            updateStatus('Nothing to redo', 'info');
                        }
                        updateXMLView();
                    }
                    break;
                case 's':
                case 'S':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        if (event.shiftKey) {
                            // Ctrl+Shift+S or Cmd+Shift+S = Manual save to cache
                            saveModelToCache();
                            updateStatus('Model manually saved to cache', 'success');
                        } else {
                            // Ctrl+S or Cmd+S = Export diagram
                            exportDiagram();
                        }
                    }
                    break;
                case 'r':
                case 'R':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        refreshCanvas();
                        updateStatus('Canvas refreshed', 'success');
                    }
                    break;
                case 'h':
                case 'H':
                    if (event.ctrlKey || event.metaKey && event.shiftKey) {
                        event.preventDefault();
                        if (currentView === 'xml') {
                            forceRefreshXMLHighlighting();
                            updateStatus('XML highlighting refreshed', 'success');
                        }
                    }
                    break;
            }
        }

        // Add keyboard event listener
        document.addEventListener('keydown', handleKeyboardEvents);

        // Enhanced clear model function
        function clearModel() {
            if (confirm('Are you sure you want to clear the entire model? This cannot be undone.')) {
                if (modeler) {
                    modeler.destroy();
                }

                // Clear cache
                clearModelCache();

                // Reset variables
                modeler = null;
                selectedElement = null;
                currentView = 'diagram';

                // Clear properties panel
                updatePropertiesPanel();

                // Reinitialize with empty model
                initModeler();

                updateStatus('Model cleared and cache removed', 'success');
            }
        }

        // Browser caching functions
        function saveModelToCache() {
            if (!modeler) return;

            modeler.saveXML({ format: true }).then(result => {
                // Inject extension properties into XML before saving to cache
                let xml = injectExtensionProperties(result.xml);

                localStorage.setItem('bpmn_model_cache', xml);
                localStorage.setItem('bpmn_model_timestamp', Date.now());
                console.log('Model saved to cache');
            }).catch(error => {
                console.error('Error saving model to cache:', error);
            });
        }

        function loadModelFromCache() {
            const cachedXML = localStorage.getItem('bpmn_model_cache');
            const timestamp = localStorage.getItem('bpmn_model_timestamp');

            if (cachedXML && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours

                if (age < maxAge) {
                    return cachedXML;
                } else {
                    // Clear expired cache
                    localStorage.removeItem('bpmn_model_cache');
                    localStorage.removeItem('bpmn_model_timestamp');
                }
            }

            return null;
        }

        function clearModelCache() {
            localStorage.removeItem('bpmn_model_cache');
            localStorage.removeItem('bpmn_model_timestamp');
            console.log('Model cache cleared');
        }

        // Test function to create a service task for testing
        window.createTestTask = function () {
            if (!modeler) return;

            const modeling = modeler.get('modeling');
            const elementFactory = modeler.get('elementFactory');
            const elementRegistry = modeler.get('elementRegistry');

            // Get the process
            const process = elementRegistry.get('Process_1');
            if (!process) {
                console.log('Process not found');
                return;
            }

            // Create a service task
            const serviceTask = elementFactory.createShape({
                type: 'bpmn:ServiceTask',
                id: 'TestServiceTask_1',
                name: 'Test Service Task'
            });

            // Add it to the process
            modeling.createShape(serviceTask, { x: 200, y: 200 }, process);

            // Select it
            const selection = modeler.get('selection');
            selection.select(serviceTask);
            selectElement(serviceTask);

            // Set default extension properties
            updateExtensionProperty(serviceTask, 'service:type', 'REST');
            updateExtensionProperty(serviceTask, 'service:name', 'UserService_TEST');
            updateExtensionProperty(serviceTask, 'service:version', '1.0');

            console.log('Test service task created and selected with default properties');
            updateStatus('Test service task created with default extension properties', 'success');
        };

        // Simple test function to check XML injection
        window.testXMLInjection = function () {
            if (!modeler) return;

            console.log('Testing XML injection...');
            modeler.saveXML({ format: true }).then(result => {
                console.log('=== ORIGINAL XML ===');
                console.log(result.xml);
                console.log('=== INJECTED XML ===');
                const injected = injectExtensionProperties(result.xml);
                console.log(injected);
            });
        };

        // Function to inject extension properties into XML
        function injectExtensionProperties(xml) {
            if (!modeler) return xml;

            console.log('Injecting extension properties into XML...');
            const elementRegistry = modeler.get('elementRegistry');

            // Find all service tasks and inject their extension properties
            elementRegistry.forEach(element => {
                const businessObject = element.businessObject;
                if (businessObject.$type === 'bpmn:ServiceTask') {
                    console.log('Found service task:', businessObject.id);
                    console.log('Attributes:', businessObject.$attrs);
                    xml = injectServiceTaskExtensions(xml, businessObject.id, businessObject.$attrs || {});
                }
            });

            console.log('Final XML length:', xml.length);
            return xml;
        }
    </script>
</body>

</html>